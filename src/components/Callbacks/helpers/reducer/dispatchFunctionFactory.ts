import type { Dispatcher } from "./reducerFunction";
import type { CallbackWithId } from "../../../../types";
import { merge } from "lodash";



/**
 * Creates dispatch functions for adding, removing, and updating items.
 * 
 * This factory function returns an object containing three methods (`add`, `remove`, `update`) 
 * tailored for dispatching actions to modify the state of a list or collection. These methods are 
 * designed to work with a dispatcher function (typically from a useReducer hook in React) and 
 * simplify the process of creating new items, updating existing items, or removing items based on 
 * an identifier. The factory utilizes lodash's `merge` function to combine partial updates with 
 * existing or default item structures, ensuring a seamless update process.
 * 
 * @param {Dispatcher} dispatch - The dispatch function from useReducer hook to dispatch actions.
 * @returns An object containing three methods: add, remove, and update.
 * 
 * @template T Extends CallbackWithId - A generic type parameter that extends the CallbackWithId type, 
 *                                      indicating the structure of items being added, removed, or updated.
 * 
 * @callback Dispatcher
 * @param {{ type: string; data: any }} action - The action object to be dispatched, 
 *                                               containing a type property and the data for the action.
 * 
 * @typedef {Object} CallbackWithId
 * @property {string} id - Unique identifier for the callback.
 * 
 * @example
 * // Assuming you have a dispatcher from a useReducer hook in a React component
 * const { add, remove, update } = dispatchFunctionFactory(dispatch);
 * 
 * // To add a new item
 * add(() => ({ id: 'newId', name: 'New Item' }), { name: 'Updated New Item Name' });
 * 
 * // To remove an item by ID
 * remove('itemId');
 * 
 * // To update an item by ID
 * update('itemId', { name: 'Updated Item Name' });
 */
const dispatchFunctionFactory = (dispatch: Dispatcher) => {

  /**
 * Creates a new item by merging the provided partial data with the defaults generated by 
 * `createDefault` function, and dispatches an action to add this new item to the state.
 * This method is useful for scenarios where you need to add a new item to your state 
 * with some predefined structure or defaults, allowing for partial overrides through 
 * the `partial` parameter. The `merge` function from lodash is used to deeply combine 
 * the partial data with the default data, ensuring any nested structures are appropriately merged.
 * 
 * @param {() => T} createDefault - A function that returns a new item with default values. 
 *                                  It serves as a template for the structure of items in the state.
 * @param {Partial<T>} partial - An object containing values that should override the defaults 
 *                               provided by `createDefault`. This allows for customization 
 *                               of the new item being added.
 * 
 * @example
 * // Define a function to create default item structure
 * const createDefaultItem = () => ({ id: generateUniqueId(), name: 'Unnamed', status: 'new' });
 * 
 * // Use the `add` method to add a new item with some overrides
 * add(createDefaultItem, { name: 'New Task' });
 * // This will dispatch an action to add an item with a unique ID, name "New Task", and status "new".
 */
  const add = <T extends CallbackWithId>(
    createDefault: () => T,
    partial: Partial<T>,
  ) => {
    const data = merge({}, createDefault(), partial);
    dispatch({ type: "add", data });
  };
  const remove = (id: string) => {
    const data = { id };
    dispatch({ type: "remove", data });
  };
  const update = (id: string, partial: Partial<CallbackWithId>) => {
    const data = { id, ...partial };
    dispatch({ type: "update", data });
  };
  return { add, remove, update };
};


export default dispatchFunctionFactory;
